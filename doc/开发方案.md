# APP开发方案

## 一、技术架构设计

### 1.1 整体架构

采用**微服务架构**，支持水平扩展和高可用性。

```
┌─────────────────────────────────────────────────────────┐
│                     移动端APP (React Native)              │
└─────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────┐
│                    API Gateway (Spring Cloud Gateway)    │
│              - 路由转发、负载均衡、限流、鉴权              │
└─────────────────────────────────────────────────────────┘
                            │
        ┌───────────────────┼───────────────────┐
        ▼                   ▼                   ▼
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│  用户服务    │  │  内容服务    │  │  活动服务    │
│ User Service │  │Content Service│  │Event Service │
└──────────────┘  └──────────────┘  └──────────────┘
        │                   │                   │
        ▼                   ▼                   ▼
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│  钱包服务    │  │  搜索服务    │  │  通知服务    │
│Wallet Service│  │Search Service│  │Notify Service │
└──────────────┘  └──────────────┘  └──────────────┘
        │                   │                   │
        └───────────────────┼───────────────────┘
                            ▼
        ┌───────────────────────────────────┐
        │      MySQL (主从复制)              │
        │      Redis (缓存/消息队列)         │
        │      Elasticsearch (全文搜索)      │
        │      RabbitMQ (消息队列)           │
        └───────────────────────────────────┘
```

### 1.2 技术选型

#### 后端技术栈
- **核心框架**：Spring Boot 2.7.x / 3.x
- **微服务框架**：Spring Cloud 2021.x / 2022.x
  - Spring Cloud Gateway（API网关）
  - Spring Cloud OpenFeign（服务调用）
  - Spring Cloud Config（配置中心）
  - Spring Cloud Sleuth（链路追踪）
- **ORM框架**：MyBatis-Plus 3.5.x
- **数据库连接池**：HikariCP
- **缓存**：Redis 6.x / 7.x
- **消息队列**：RabbitMQ 3.11.x
- **全文搜索**：Elasticsearch 7.x / 8.x
- **任务调度**：XXL-Job 2.3.x
- **API 设计与协作**：在线 Apifox（https://app.apifox.com/）进行接口设计、文档与 Mock
- **工具类库**：Hutool、Lombok、MapStruct

#### 数据库
- **主数据库**：MySQL 8.0+
- **缓存数据库**：Redis 6.x / 7.x
- **搜索引擎**：Elasticsearch 7.x / 8.x

#### 基础设施
- **容器化**：Docker + Docker Compose
- **容器编排**：Kubernetes（生产环境）
- **CI/CD**：Jenkins / GitLab CI
- **监控**：Prometheus + Grafana
- **日志**：ELK Stack (Elasticsearch + Logstash + Kibana)
- **链路追踪**：Zipkin / SkyWalking

#### 第三方服务
- **支付**：Stripe / PayPal SDK
- **地图服务**：Google Maps API
- **社交登录**：Spring Social (Facebook/Twitter OAuth/Ins)
- **推送通知**：Firebase Cloud Messaging (FCM)
- **文件存储**：AWS S3 / 阿里云OSS
- **CDN**：Cloudflare / AWS CloudFront
- **短信服务**：Twilio / AWS SNS

---

## 二、数据库设计

### 2.1 数据库设计原则

1. **分库分表策略**：
   - 按业务模块分库（用户库、内容库、活动库等）
   - 大数据量表采用分表策略（如问题表、回答表按时间分表）
   - 使用ShardingSphere-JDBC实现分库分表

2. **索引优化**：
   - 主键使用自增ID或雪花算法ID
   - 高频查询字段建立索引
   - 联合索引优化多条件查询
   - 避免过度索引

3. **读写分离**：
   - MySQL主从复制
   - 使用ShardingSphere-JDBC实现读写分离

---

## 三、系统架构设计

### 3.1 微服务拆分

#### 3.1.1 用户服务 (user-service)
**职责**：
- 用户注册、登录、认证
- 用户信息管理
- 用户关注/粉丝关系
- 用户统计信息

**技术要点**：
- JWT Token认证
- Spring Security安全框架
- Redis存储Session/Token
- 用户信息缓存

#### 3.1.2 内容服务 (content-service)
**职责**：
- 问题CRUD
- 回答CRUD
- 补充CRUD
- 评论CRUD
- 内容审核

**技术要点**：
- 分表策略（按时间分表）
- 内容审核（接入第三方审核API）
- 内容缓存

#### 3.1.3 活动服务 (activity-service)
**职责**：
- 活动CRUD
- 活动报名
- 活动状态管理

**技术要点**：
- 活动状态机
- 报名人数控制（Redis分布式锁）
- 定时任务更新活动状态

#### 3.1.4 钱包服务 (wallet-service)
**职责**：
- 钱包余额管理
- 充值/提现
- 交易流水
- 支付集成

**技术要点**：
- 分布式事务（Seata）
- 金额计算精度（BigDecimal）
- 防重复支付
- 支付回调处理

#### 3.1.5 搜索服务 (search-service)
**职责**：
- 全文搜索
- 搜索建议
- 热门搜索

**技术要点**：
- Elasticsearch索引管理
- 搜索关键词高亮
- 搜索结果排序算法
- 搜索日志分析

#### 3.1.6 通知服务 (notify-service)
**职责**：
- 站内通知
- 推送通知
- 消息模板管理

**技术要点**：
- RabbitMQ消息队列
- FCM推送
- 通知去重
- 批量推送优化

#### 3.1.7 互动服务 (interaction-service)
**职责**：
- 点赞/点踩
- 收藏
- 浏览历史
- 统计计数

**技术要点**：
- Redis计数器
- 异步更新数据库
- 防刷机制
- 统计聚合

### 3.2 API网关设计

**功能**：
- 路由转发
- 统一鉴权
- 限流熔断
- 请求日志
- 跨域处理

### 3.3 服务间通信

**同步调用**：Spring Cloud OpenFeign 进行服务间同步调用。

**异步消息**：RabbitMQ
- 点赞/收藏等操作异步处理
- 通知消息异步发送
- 统计数据异步更新

---

## 四、性能优化方案

### 4.1 数据库优化

1. **索引优化**：主键自增或雪花算法，高频查询建索引，按需查字段，覆盖索引减回表。
2. **查询优化**：分页用游标、避免深度分页，复杂查询拆分，避免全表扫描与 N+1；分页限制最大深度。
3. **连接池**：按并发设置最小/最大连接数、超时与生存时间。
4. **读写分离**：主库写、从库读，ShardingSphere-JDBC 配置数据源与负载。
5. **分库分表**：按业务分库、按时间分表，分片键与路由算法（取模/一致性哈希）明确。

### 4.2 缓存策略

1. **缓存更新**：Cache Aside 等模式，先更新库再删缓存，合理 TTL；双写一致性可用消息队列保证。
2. **热点数据**：热榜、用户信息、问题详情等按访问频率设置过期时间。
3. **穿透/击穿/雪崩**：防穿透（布隆过滤器、空值缓存、参数校验）；防击穿（分布式锁、热点预热）；防雪崩（过期时间随机化、降级到 DB）。不再采用多级缓存。

### 4.3 异步处理

1. **消息队列**：点赞/收藏等异步处理，统计异步更新，通知异步发送；批量消费、并发消费、消息压缩与去重。
2. **线程池**：按业务隔离，核心/最大线程数、队列与拒绝策略合理；重要任务高优先级队列，记录执行时间与失败率。

### 4.4 接口优化

1. **接口设计与文档**：
   - RESTful API 设计，统一响应格式与接口版本
   - 使用在线 Apifox（https://app.apifox.com/）进行接口设计、文档维护、Mock 与协作

2. **响应与性能**：
   - 数据压缩（Gzip）、分页返回、字段过滤、批量接口；目标 P95 小于 200ms、P99 小于 500ms；减少 DB 查询、用缓存、异步非关键路径。

3. **并发与线程池**：核心/最大线程数、队列与拒绝策略按业务设置（如 CPU 核数倍数）；按业务隔离线程池。

4. **限流与熔断**：见下节「限流熔断方案」。

### 4.5 限流熔断方案

#### 4.5.1 限流策略
- **限流维度**：按用户（userId）、按 IP、按接口路径、按全局限流；可组合使用（如「单用户 + 单接口」）。
- **限流算法**：令牌桶或漏桶，网关层统一限流（如 Spring Cloud Gateway + Redis），必要时在业务层对核心接口做二次限流。
- **限流阈值**：按接口重要性分级（如登录/注册更严、列表/详情稍松），设置 QPS 或并发数上限；支持按环境配置（测试/生产）。
- **超限处理**：返回 429 或统一错误码，响应体中说明限流原因与建议重试时间；前端可做友好提示与自动重试。

#### 4.5.2 熔断策略
- **熔断触发条件**：基于错误率（如 5xx 占比 > 50%）、慢调用比例（如 RT > 2s 的请求占比 > 80%）、连续失败次数；按时间窗口统计（如 10s 滑动窗口）。
- **熔断状态**：关闭 → 打开（触发后拒绝调用）→ 半开（放行部分请求探测）；半开成功则关闭，失败则再次打开。
- **熔断粒度**：按下游服务或按接口熔断；关键路径与非关键路径区分（如支付、下单必须熔断，推荐、统计可降级）。

#### 4.5.3 降级策略
- **自动降级**：熔断打开时返回默认值、缓存数据或简短提示（如「服务繁忙，请稍后再试」）；非核心功能可直接关闭（如关闭推荐、热榜）。
- **手动降级**：通过配置中心或开关，在高峰或故障时关闭部分功能（如关闭评论、关闭活动报名）。
- **降级链**：定义降级优先级（如先读缓存 → 再读备用接口 → 最后返回默认文案），避免雪崩。

---

## 五、扩展性设计

### 5.1 水平扩展

1. **无状态服务**：
   - 服务不存储状态
   - Session存储在Redis
   - 支持多实例部署

2. **数据库扩展**：
   - 读写分离
   - 分库分表
   - 使用ShardingSphere-JDBC

3. **缓存扩展**：
   - Redis集群模式
   - 分片策略

### 5.2 服务治理

1. **服务注册发现**：
   - Nacos / Eureka
   - 健康检查
   - 负载均衡

2. **配置管理**：
   - Spring Cloud Config
   - Nacos Config
   - 配置热更新

3. **链路追踪**：
   - SkyWalking
   - Zipkin
   - 分布式追踪

### 5.3 监控告警

1. **应用监控**：
   - Prometheus + Grafana
   - JVM监控
   - 接口监控
   - 业务指标监控

2. **日志管理**：
   - ELK Stack
   - 日志收集
   - 日志分析
   - 错误告警

---

## 六、安全设计

### 6.1 认证授权

1. **JWT Token**：
   - Access Token（短期有效）
   - Refresh Token（长期有效）
   - Token刷新机制

2. **权限控制**：
   - RBAC角色权限模型
   - 接口权限校验
   - 数据权限控制

### 6.2 数据安全

1. **数据加密**：
   - 密码加密（BCrypt）
   - 敏感数据加密存储
   - HTTPS传输加密

2. **SQL注入防护**：
   - 使用PreparedStatement
   - MyBatis参数化查询
   - 输入验证

3. **XSS防护**：
   - 输入过滤
   - 输出转义
   - CSP内容安全策略

### 6.3 接口安全

1. **防刷机制**：
   - 接口限流
   - 验证码
   - IP白名单/黑名单

2. **参数校验**：
   - Bean Validation
   - 自定义校验器
   - 参数类型检查

---

## 七、技术难点与解决方案

### 7.1 热榜算法

**难点**：实时计算热度分数，支持多维度排序

**解决方案**：
1. 使用Redis Sorted Set存储热榜
2. 热度分数计算公式????推荐算法？？？？
3. 定时任务更新热榜
4. 使用Elasticsearch聚合查询

### 7.2 分布式事务

**难点**：跨服务事务一致性（如悬赏支付）

**解决方案**：
1. 使用Seata分布式事务框架
2. TCC模式（Try-Confirm-Cancel）
3. 最终一致性（消息队列补偿）

### 7.3 高并发写入

**难点**：点赞、浏览等高频操作

**解决方案**：
1. Redis计数器
2. 异步批量更新数据库
3. 使用消息队列削峰
4. 数据库批量插入优化

### 7.4 全文搜索

**难点**：中文分词、搜索相关性排序

**解决方案**：
1. Elasticsearch IK 分词器
2. 自定义评分算法
3. 搜索建议（Completion Suggester）
4. 搜索结果高亮

### 7.5 App 外推送的稳定性与可靠性

**难点**：推送依赖厂商/第三方通道（如 FCM、APNs），存在送达率、延迟、不同机型/地区表现不一致等问题；用户关闭通知、省电策略、网络波动也会影响到达。

**解决方案**：
1. **多通道与降级**：优先使用 FCM/APNs，失败或不可用时降级到厂商通道或自有长连接（若有）；对关键通知可「推送 + 站内信 + 短信」互补。
2. **推送内容与策略**：控制频率与时段，避免被系统归类为骚扰；重要通知（如悬赏采纳、紧急求助）可提高优先级并支持重试。
3. **设备与 token 管理**：正确维护设备 token 的注册、刷新、失效；定期清理无效 token，避免无效请求拉低成功率。
4. **监控与兜底**：对发送量、到达率、点击率、失败原因做监控与告警；对重要业务提供「未达可查」与补发能力（如站内信补发）。

### 7.6 支付接入

**难点**：海外支付需对接 Stripe、PayPal 等，涉及合规、币种、退款、对账、风控；支付链路长，任何一环异常都会影响资金与体验。

**解决方案**：
1. **统一支付层**：抽象支付能力（下单、查询、退款、回调），对接多家支付渠道并做路由与降级；金额、币种、幂等等在统一层保证一致性。
2. **安全与合规**：敏感数据不落库或加密存储；遵守 PCI-DSS、各地区支付与隐私法规；回调验签、防重放、幂等处理必须严格。
3. **对账与监控**：每日与支付方对账，差异告警与人工处理；对支付成功率、超时、失败原因做监控，便于排查与优化。
4. **异常与重试**：区分可重试与不可重试错误；提供明确的失败原因与用户提示；退款、部分退款流程与状态机清晰可追溯。

---

## 八、项目结构

后端按模块划分：网关、公共模块（核心/安全/Web）、用户服务、内容服务、活动服务、钱包服务、搜索服务、通知服务、互动服务。各服务内可按 API、Service、DAO 分层。

---

## 九、开发规范

### 9.1 代码规范

#### 9.1.1 编码规范
- **Java编码规范**：遵循阿里巴巴Java开发手册
- **代码格式化**：使用Google Java Format
- **代码检查**：使用Checkstyle、PMD、SpotBugs
- **代码审查**：所有代码必须经过Code Review

#### 17.1.2 命名规范
- **类名**：大驼峰（PascalCase）
- **方法名**：小驼峰（camelCase）
- **常量**：全大写下划线分隔（UPPER_SNAKE_CASE）
- **包名**：全小写，点分隔

#### 9.1.3 注释规范
- **类注释**：说明类的作用、作者、创建时间
- **方法注释**：说明方法功能、参数、返回值
- **复杂逻辑注释**：说明业务逻辑和算法

### 9.2 Git工作流

#### 9.2.1 分支策略
- **master分支**：生产环境代码，只接受合并
- **develop分支**：开发环境代码，功能开发分支
- **feature分支**：功能开发分支，从develop创建
- **hotfix分支**：紧急修复分支，从master创建
- **release分支**：发布分支，从develop创建

#### 17.2.2 提交规范
- **提交信息格式**：`<type>(<scope>): <subject>`
- **类型**：feat、fix、docs、style、refactor、test、chore
- **范围**：模块名称
- **主题**：简洁描述变更内容

---

## 十、第三方服务集成方案

### 10.1 支付服务集成

#### 10.1.1 Stripe集成
- **集成方式**：Stripe Java SDK
- **支付流程**：
  1. 前端调用Stripe.js创建支付意图
  2. 后端调用Stripe API确认支付
  3. 处理支付回调
  4. 更新订单状态

#### 19.1.2 PayPal集成
- **集成方式**：PayPal REST API
- **支付流程**：类似Stripe
- **安全措施**：IPN验证、Webhook验证

### 10.2 地图服务集成

#### 10.2.1 Google Maps API
- **功能**：地理编码、反向地理编码、距离计算
- **API Key管理**：环境变量存储，定期轮换
- **配额限制**：监控API调用量，避免超限

### 10.3 推送服务集成

#### 10.3.1 Firebase Cloud Messaging
- **集成方式**：Firebase Admin SDK
- **推送类型**：通知消息、数据消息
- **推送策略**：批量推送、定时推送、个性化推送


---

## 十一、总结

本开发方案基于Java技术栈，采用微服务架构，使用MySQL作为主数据库，充分考虑了扩展性和性能要求。通过合理的架构设计、数据库优化、缓存策略和异步处理，能够支撑大规模用户并发访问。

### 关键要点：

1. **微服务架构**：服务拆分合理，职责清晰，支持独立部署和扩展
2. **数据库设计**：索引优化，支持读写分离和分库分表
3. **性能优化**：缓存策略（含穿透/击穿/雪崩防护）、异步处理、读写分离、接口优化、限流熔断
4. **扩展性**：水平扩展、服务治理、监控告警、自动扩缩容
5. **安全性**：认证授权、数据加密、接口安全、防刷机制
6. **技术难点**：热榜、分布式事务、高并发、全文搜索、推送稳定性、支付接入等有对应方案

### 实施建议：

1. **持续优化**：根据监控数据和用户反馈持续优化
2. **文档完善**：保持技术文档和 API 文档（含 Apifox）及时更新
3. **团队协作**：建立代码审查、技术分享等协作机制
4. **风险控制**：制定应急预案，定期演练故障处理流程
