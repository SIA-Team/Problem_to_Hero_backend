# 开发规范文档

## 一、项目技术栈介绍

### 1.1 核心框架

| 技术 | 版本 | 说明 |
|------|------|------|
| **Spring Boot** | 3.2.5 | 核心框架，提供自动配置和快速开发能力 |
| **Spring Cloud** | 2023.0.1 | 微服务框架，提供服务治理能力 |
| **Java** | 21 | JDK版本，使用 JDK 21 |

### 1.2 微服务组件

| 组件 | 版本 | 说明 |
|------|------|------|
| **Spring Cloud Gateway** | 4.0.9 | API网关，负责路由转发、负载均衡、限流、鉴权 |
| **Spring Cloud OpenFeign** | 4.0.9 | 服务间调用，基于HTTP的声明式调用 |
| **Spring Cloud Config** | 4.0.9 | 配置中心，统一管理配置 |
| **Micrometer Tracing** | 1.2.3 | 链路追踪（替代Spring Cloud Sleuth） |

### 1.3 数据存储

| 技术 | 版本 | 说明 |
|------|------|------|
| **MySQL** | 8.0+ | 主数据库，支持主从复制、读写分离 |
| **Redis** | 6.x / 7.x | 缓存数据库，用于Session/Token存储、热点数据缓存、分布式锁 |
| **Elasticsearch** | 7.x / 8.x | 全文搜索引擎，用于内容搜索 |
| **RabbitMQ** | 3.11.x | 消息队列，用于异步任务处理 |

### 1.4 ORM与工具

| 技术 | 版本 | 说明 |
|------|------|------|
| **MyBatis-Plus** | 3.5.5 | ORM框架，简化数据库操作 |
| **HikariCP** | 5.1.0 | 数据库连接池（Spring Boot默认，性能优秀） |
| **Hutool** | 5.8.25 | Java工具类库 |
| **Lombok** | 1.18.30 | 代码简化，减少样板代码 |
| **MapStruct** | 1.5.5.Final | 对象映射工具 |

#### 1.4.1 数据库连接池选择：HikariCP vs Druid

**HikariCP（已选择）**

**优势**：
- ✅ **性能最优**：号称"史上最快"的连接池，性能远超其他连接池
- ✅ **轻量级**：代码量少，依赖少，启动快
- ✅ **Spring Boot默认**：Spring Boot 2.0+默认使用HikariCP
- ✅ **JDK 21兼容性好**：对Java新特性支持好
- ✅ **连接泄漏检测**：内置连接泄漏检测机制
- ✅ **零配置**：默认配置即可满足大部分场景

**劣势**：
- ❌ **监控功能较弱**：相比Druid，监控和统计功能较少
- ❌ **SQL监控缺失**：不支持SQL监控和慢SQL记录

**适用场景**：
- 高性能要求的应用
- 微服务架构（轻量级）
- Spring Boot项目（默认集成）

**Druid（备选方案）**

**优势**：
- ✅ **功能丰富**：提供SQL监控、慢SQL记录、防火墙等功能
- ✅ **监控完善**：内置监控页面，可查看连接池状态、SQL统计等
- ✅ **安全防护**：支持SQL注入检测、黑白名单等安全功能
- ✅ **扩展性强**：支持插件扩展

**劣势**：
- ❌ **性能略低**：性能不如HikariCP
- ❌ **配置复杂**：需要更多配置项
- ❌ **依赖较多**：相比HikariCP依赖更多

**适用场景**：
- 需要SQL监控和慢SQL分析
- 需要连接池详细统计信息
- 对安全要求较高的场景

**选择建议**：
- **本项目选择HikariCP**：因为Spring Boot默认集成，性能优秀，满足微服务架构需求
- 如需SQL监控，可单独集成P6Spy或使用APM工具（如SkyWalking）

### 1.5 安全与认证

| 技术 | 版本 | 说明 |
|------|------|------|
| **Spring Security** | 6.2.3 | 安全框架，提供认证授权能力 |
| **JJWT** | 0.12.5 | JWT Token生成与验证库 |
| **BCrypt** | 0.10.2 | 密码加密算法（Spring Security内置） |

### 1.6 任务调度

| 技术 | 版本 | 说明 |
|------|------|------|
| **XXL-Job** | 2.4.0 | 分布式任务调度平台 |

### 1.7 基础设施

| 技术 | 说明 |
|------|------|
| **Docker + Docker Compose** | 容器化部署，本地开发环境 |
| **Kubernetes** | 容器编排，生产环境 |
| **Jenkins / GitLab CI** | CI/CD持续集成与部署 |
| **Prometheus + Grafana** | 监控与可视化 |
| **ELK Stack** | 日志收集与分析（Elasticsearch + Logstash + Kibana） |
| **Zipkin / SkyWalking** | 链路追踪 |

### 1.8 第三方服务

| 服务 | 说明 |
|------|------|
| **Apifox** | API设计与协作平台（https://app.apifox.com/） |
| **Stripe / PayPal** | 支付服务 |
| **Google Maps API** | 地图服务 |
| **Firebase Cloud Messaging** | 推送通知 |
| **AWS S3 / 阿里云OSS** | 文件存储 |
| **Cloudflare / AWS CloudFront** | CDN服务 |
| **Twilio / AWS SNS** | 短信服务 |

---

## 二、JWT使用与第三方登录验证

### 2.1 JWT简介

JWT（JSON Web Token）是一种无状态的认证方案，由三部分组成：
- **Header（头部）**：声明类型和签名算法
- **Payload（载荷）**：存放用户信息和其他数据
- **Signature（签名）**：用于验证Token的完整性

**优势**：
- ✅ 无状态：服务端不需要存储Session
- ✅ 跨域友好：支持跨域请求
- ✅ 可扩展：Payload可自定义字段
- ✅ 安全性：使用签名防止篡改

### 2.2 JWT使用流程

#### 2.2.1 Token生成

```java
// 使用JJWT生成Token
public String generateToken(Long userId, String username) {
    return Jwts.builder()
        .setSubject(String.valueOf(userId))
        .claim("username", username)
        .setIssuedAt(new Date())
        .setExpiration(new Date(System.currentTimeMillis() + EXPIRE_TIME))
        .signWith(Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8)))
        .compact();
}
```

#### 2.2.2 Token验证

```java
// 验证Token并解析用户信息
public Claims parseToken(String token) {
    try {
        return Jwts.parserBuilder()
            .setSigningKey(Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8)))
            .build()
            .parseClaimsJws(token)
            .getBody();
    } catch (JwtException e) {
        throw new TokenInvalidException("Token无效或已过期");
    }
}
```

#### 2.2.3 Token刷新

```java
// 刷新Token（使用Refresh Token）
public String refreshToken(String refreshToken) {
    Claims claims = parseToken(refreshToken);
    Long userId = Long.parseLong(claims.getSubject());
    String username = claims.get("username", String.class);
    return generateToken(userId, username);
}
```

### 2.3 第三方登录验证流程

#### 2.3.1 OAuth2.0流程（以Twitter为例）

```
1. 用户点击"Twitter登录"
   ↓
2. 前端跳转到Twitter授权页面
   ↓
3. 用户授权后，Twitter回调后端接口，携带code
   ↓
4. 后端使用code换取access_token
   ↓
5. 使用access_token获取用户信息（Twitter API）
   ↓
6. 检查用户是否已注册
   - 已注册：直接登录，生成JWT Token
   - 未注册：自动注册并登录，生成JWT Token
   ↓
7. 返回JWT Token给前端
```

#### 2.3.2 第三方登录实现示例

```java
@Service
public class OAuthService {
    
    @Autowired
    private TwitterOAuth2Client twitterClient;
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private JwtUtil jwtUtil;
    
    /**
     * Twitter OAuth2登录
     */
    public LoginVO twitterLogin(String code) {
        // 1. 使用code换取access_token
        OAuth2AccessToken accessToken = twitterClient.getAccessToken(code);
        
        // 2. 使用access_token获取用户信息
        TwitterUserInfo twitterUser = twitterClient.getUserInfo(accessToken);
        
        // 3. 查找或创建用户
        User user = findOrCreateUser(twitterUser);
        
        // 4. 生成JWT Token
        String token = jwtUtil.generateToken(user.getId(), user.getUsername());
        String refreshToken = jwtUtil.generateRefreshToken(user.getId());
        
        // 5. 返回登录结果
        return LoginVO.builder()
            .token(token)
            .refreshToken(refreshToken)
            .user(user)
            .build();
    }
    
    /**
     * 查找或创建用户
     */
    private User findOrCreateUser(TwitterUserInfo twitterUser) {
        // 根据第三方用户ID查找
        User user = userService.findByThirdPartyId(
            ThirdPartyType.TWITTER, 
            twitterUser.getId()
        );
        
        if (user == null) {
            // 创建新用户
            UserCreateDTO userDTO = UserCreateDTO.builder()
                .username(twitterUser.getUsername())
                .nickname(twitterUser.getName())
                .avatar(twitterUser.getAvatar())
                .thirdPartyType(ThirdPartyType.TWITTER)
                .thirdPartyId(twitterUser.getId())
                .build();
            user = userService.createUser(userDTO);
        } else {
            // 更新用户信息（头像、昵称等可能变化）
            user.setAvatar(twitterUser.getAvatar());
            user.setNickname(twitterUser.getName());
            userService.updateUser(user);
        }
        
        return user;
    }
}
```

### 2.4 JWT与第三方登录结合方案

#### 2.4.1 统一认证流程

```
用户登录方式：
├── 账号密码登录
│   ├── 验证用户名密码
│   ├── 生成JWT Token
│   └── 返回Token
│
└── 第三方登录（Twitter/Facebook/Instagram）
    ├── OAuth2授权
    ├── 获取第三方用户信息
    ├── 查找或创建本地用户
    ├── 生成JWT Token（与账号密码登录相同）
    └── 返回Token
```

#### 2.4.2 Token Payload设计

```java
// JWT Payload结构
{
    "sub": "123456",              // 用户ID
    "username": "testuser",        // 用户名
    "loginType": "PASSWORD",      // 登录类型：PASSWORD/TWITTER/FACEBOOK
    "thirdPartyId": "twitter_123", // 第三方用户ID（可选）
    "iat": 1706601600,            // 签发时间
    "exp": 1706688000              // 过期时间
}
```

#### 2.4.3 网关层JWT验证

```java
@Component
public class JwtAuthFilter implements GatewayFilter {
    
    @Autowired
    private JwtUtil jwtUtil;
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        String token = getTokenFromRequest(request);
        
        if (token == null) {
            // 白名单接口放行
            if (isWhitelist(request.getURI().getPath())) {
                return chain.filter(exchange);
            }
            return unauthorized(exchange);
        }
        
        try {
            // 验证Token
            Claims claims = jwtUtil.parseToken(token);
            
            // 将用户信息添加到Header，传递给下游服务
            ServerHttpRequest modifiedRequest = request.mutate()
                .header("X-User-Id", claims.getSubject())
                .header("X-Username", claims.get("username", String.class))
                .build();
            
            return chain.filter(exchange.mutate().request(modifiedRequest).build());
        } catch (Exception e) {
            return unauthorized(exchange);
        }
    }
}
```

### 2.5 安全注意事项

#### 2.5.1 Token安全
- ✅ **使用HTTPS**：防止Token被截获
- ✅ **设置合理过期时间**：Access Token建议15分钟，Refresh Token建议7天
- ✅ **Token存储在HttpOnly Cookie**：防止XSS攻击（Web端）
- ✅ **Token存储在Secure Storage**：移动端使用Keychain/Keystore
- ✅ **使用Refresh Token机制**：避免频繁重新登录

#### 2.5.2 第三方登录安全
- ✅ **验证state参数**：防止CSRF攻击
- ✅ **验证回调URL**：确保回调来自可信源
- ✅ **存储第三方用户ID映射**：用于关联本地用户
- ✅ **处理Token刷新**：第三方Token过期时的处理

### 2.6 数据库设计

```sql
-- 用户表
CREATE TABLE user (
    id BIGINT PRIMARY KEY,
    username VARCHAR(50) UNIQUE,
    password VARCHAR(255),  -- 第三方登录用户可能为空
    nickname VARCHAR(100),
    avatar VARCHAR(500),
    create_time DATETIME,
    update_time DATETIME
);

-- 第三方登录关联表
CREATE TABLE user_third_party (
    id BIGINT PRIMARY KEY,
    user_id BIGINT,
    third_party_type VARCHAR(20),  -- TWITTER/FACEBOOK/INSTAGRAM
    third_party_id VARCHAR(100),   -- 第三方用户ID
    access_token VARCHAR(500),     -- 第三方Token（加密存储）
    refresh_token VARCHAR(500),     -- 第三方Refresh Token（加密存储）
    expire_time DATETIME,
    create_time DATETIME,
    UNIQUE KEY uk_user_third_party (user_id, third_party_type, third_party_id)
);
```

---

## 三、工程模块及目录说明

### 2.1 整体项目结构

```
problem-to-hero-backend/
├── doc/                          # 文档目录
│   ├── 开发方案.md
│   ├── 功能需求优先级.md
│   ├── 第一阶段框架搭建计划.md
│   ├── 模块与目录结构定义.md
│   └── 开发规范.md
├── common/                       # 公共模块
│   ├── common-core/              # 核心公共模块
│   ├── common-security/          # 安全公共模块
│   ├── common-web/               # Web公共模块
│   └── common-dbservice/         # 数据库服务模块（DAO层公共模块）
├── gateway/                      # API网关
│   └── api-gateway/
├── services/                     # 业务服务
│   ├── user-service/             # 用户服务
│   ├── content-service/          # 内容服务
│   ├── activity-service/         # 活动服务
│   ├── wallet-service/           # 钱包服务
│   ├── search-service/           # 搜索服务
│   ├── notify-service/           # 通知服务
│   └── interaction-service/     # 互动服务
├── sql/                          # SQL脚本
│   └── init.sql
├── docker-compose.yml            # Docker Compose配置
├── pom.xml                       # 父POM
└── README.md                     # 项目说明
```

### 2.2 公共模块结构

#### 2.2.1 common-core（核心公共模块）

```
common-core/
├── src/
│   └── main/
│       └── java/
│           └── com/
│               └── sia/
│                   └── common/
│                       └── core/
│                           ├── constant/        # 常量类
│                           ├── enum/            # 枚举类
│                           ├── exception/       # 异常类
│                           ├── util/            # 工具类
│                           └── id/              # ID生成器（雪花算法）
```

**职责**：
- 提供通用常量、枚举、异常定义
- 提供通用工具类（日期、字符串、集合等）
- 提供ID生成器（雪花算法）

#### 2.2.2 common-security（安全公共模块）

```
common-security/
├── src/
│   └── main/
│       └── java/
│           └── com/
│               └── sia/
│                   └── common/
│                       └── security/
│                           ├── jwt/             # JWT工具类
│                           ├── password/        # 密码加密工具
│                           └── config/          # 安全配置
```

**职责**：
- 提供JWT Token生成与验证工具
- 提供密码加密工具（BCrypt）
- 提供安全相关配置

#### 2.2.3 common-web（Web公共模块）

```
common-web/
├── src/
│   └── main/
│       └── java/
│           └── com/
│               └── sia/
│                   └── common/
│                       └── web/
│                           ├── result/          # 统一响应类
│                           ├── exception/       # 全局异常处理
│                           ├── interceptor/     # 拦截器
│                           └── validation/      # 参数验证
```

**职责**：
- 提供统一响应格式（Result<T>）
- 提供全局异常处理器
- 提供统一拦截器
- 提供参数验证工具

#### 2.2.4 common-dbservice（数据库服务模块）

```
common-dbservice/
├── src/
│   └── main/
│       └── java/
│           └── com/
│               └── sia/
│                   └── common/
│                       └── dbservice/
│                           ├── config/            # MyBatis配置
│                           │   ├── MyBatisConfig.java
│                           │   └── DataSourceConfig.java
│                           ├── base/              # 基础Mapper
│                           │   └── BaseMapper.java
│                           ├── handler/           # 类型处理器
│                           │   ├── LocalDateTimeTypeHandler.java
│                           │   └── JsonTypeHandler.java
│                           └── interceptor/       # MyBatis拦截器
│                               ├── PageInterceptor.java
│                               └── SqlLogInterceptor.java
└── pom.xml
```

**职责**：
- 提供MyBatis-Plus基础配置
- 提供BaseMapper基类（扩展MyBatis-Plus的BaseMapper）
- 提供通用类型处理器（日期、JSON等）
- 提供MyBatis拦截器（分页、SQL日志等）
- 统一管理数据库相关依赖

**使用方式**：
业务服务通过Maven依赖引入：
```xml
<dependency>
    <groupId>com.sia</groupId>
    <artifactId>common-dbservice</artifactId>
    <version>1.0.0</version>
</dependency>
```

**优势**：
- ✅ **统一DAO层配置**：避免每个服务重复配置
- ✅ **代码复用**：BaseMapper、类型处理器等可复用
- ✅ **易于维护**：数据库相关配置集中管理
- ✅ **版本统一**：MyBatis-Plus等依赖版本统一管理

### 2.3 网关模块结构

```
api-gateway/
├── src/
│   └── main/
│       ├── java/
│       │   └── com/
│       │       └── sia/
│       │           └── gateway/
│       │               ├── GatewayApplication.java
│       │               ├── config/              # 配置类
│       │               │   ├── GatewayConfig.java
│       │               │   └── CorsConfig.java
│       │               ├── filter/             # 过滤器
│       │               │   └── JwtAuthFilter.java
│       │               └── handler/             # 处理器
│       └── resources/
│           └── application.yml
```

**职责**：
- 路由转发：将请求转发到对应的业务服务
- 统一鉴权：JWT Token验证
- 跨域处理：CORS配置
- 限流熔断：限流与熔断策略

### 2.4 业务服务通用结构（以user-service为例）

```
user-service/
├── src/
│   └── main/
│       ├── java/
│       │   └── com/
│       │       └── sia/
│       │           └── user/
│       │               ├── UserServiceApplication.java
│       │               ├── api/                 # API层（Controller）
│       │               │   └── controller/
│       │               │       └── UserController.java
│       │               ├── service/             # Service层
│       │               │   ├── UserService.java
│       │               │   └── impl/
│       │               │       └── UserServiceImpl.java
│       │               ├── dao/                 # DAO层（Mapper）
│       │               │   └── mapper/
│       │               │       └── UserMapper.java
│       │               ├── entity/              # 实体类
│       │               │   └── User.java
│       │               ├── dto/                 # 数据传输对象
│       │               │   ├── request/
│       │               │   └── response/
│       │               ├── vo/                  # 视图对象
│       │               └── config/             # 配置类
│       └── resources/
│           ├── mapper/                          # MyBatis Mapper XML
│           │   └── UserMapper.xml
│           └── application.yml
```

**分层说明**：
- **API层（Controller）**：接收HTTP请求，参数验证，调用Service层
- **Service层**：业务逻辑处理，事务管理
- **DAO层（Mapper）**：数据库操作，SQL映射（继承common-dbservice的BaseMapper）

**注意**：
- DAO层配置已由`common-dbservice`模块提供，业务服务只需引入依赖即可
- Mapper接口继承`com.sia.common.dbservice.base.BaseMapper<T>`
- MyBatis配置、数据源配置等已在`common-dbservice`中统一配置

### 2.5 包命名规范

- **包名**：全小写，点分隔，如 `com.sia.user.api.controller`
- **模块包名**：`com.sia.{module}`，如 `com.sia.user`、`com.sia.content`
- **公共模块包名**：`com.sia.common.{module}`，如 `com.sia.common.core`

---

## 三、代码规范

### 3.1 编码规范

#### 3.1.1 Java编码规范
- **遵循标准**：阿里巴巴Java开发手册
- **代码格式化**：使用Google Java Format
- **代码检查工具**：
  - Checkstyle：代码风格检查
  - PMD：代码质量检查
  - SpotBugs：Bug检测
- **代码审查**：所有代码必须经过Code Review才能合并

#### 3.1.2 命名规范

| 类型 | 规范 | 示例 |
|------|------|------|
| **类名** | 大驼峰（PascalCase） | `UserController`、`UserService` |
| **接口名** | 大驼峰，以I开头或直接命名 | `UserService`、`IUserService` |
| **方法名** | 小驼峰（camelCase） | `getUserById`、`createUser` |
| **变量名** | 小驼峰（camelCase） | `userId`、`userName` |
| **常量** | 全大写下划线分隔（UPPER_SNAKE_CASE） | `MAX_RETRY_COUNT`、`DEFAULT_PAGE_SIZE` |
| **包名** | 全小写，点分隔 | `com.sia.user.api.controller` |
| **数据库表名** | 小写下划线分隔 | `user_info`、`question_detail` |
| **数据库字段名** | 小写下划线分隔 | `user_id`、`create_time` |

#### 3.1.3 注释规范

**类注释**：
```java
/**
 * 用户服务实现类
 * 
 * @author YourName
 * @date 2026/01/30
 */
public class UserServiceImpl implements UserService {
    // ...
}
```

**方法注释**：
```java
/**
 * 根据用户ID获取用户信息
 * 
 * @param userId 用户ID
 * @return 用户信息
 * @throws UserNotFoundException 用户不存在时抛出
 */
public UserVO getUserById(Long userId) {
    // ...
}
```

**复杂逻辑注释**：
```java
// 使用雪花算法生成用户ID，保证分布式环境下ID唯一性
Long userId = idGenerator.nextId();

// 使用BCrypt加密密码，安全强度高，支持自动加盐
String encodedPassword = passwordEncoder.encode(rawPassword);
```

### 3.2 代码风格

#### 3.2.1 代码格式
- 使用4个空格缩进（不使用Tab）
- 每行代码不超过120个字符
- 方法之间空一行
- 类成员变量之间空一行

#### 3.2.2 异常处理
- 使用具体的异常类型，避免使用`Exception`
- 异常信息要清晰明确
- 不要忽略异常，至少要记录日志
- 使用全局异常处理器统一处理异常

```java
// 好的做法
try {
    userService.createUser(userDTO);
} catch (DuplicateUserException e) {
    log.error("用户已存在: {}", userDTO.getUsername(), e);
    throw new BusinessException(ResultCodeEnum.USER_ALREADY_EXISTS);
}

// 不好的做法
try {
    userService.createUser(userDTO);
} catch (Exception e) {
    // 忽略异常
}
```

#### 3.2.3 日志规范
- 使用SLF4J + Logback
- 日志级别：
  - `ERROR`：错误信息，需要立即处理
  - `WARN`：警告信息，需要注意
  - `INFO`：重要业务流程信息
  - `DEBUG`：调试信息，开发环境使用
- 日志格式：包含时间、级别、类名、方法名、消息
- 敏感信息不要记录到日志（密码、Token、银行卡号等）

```java
// 好的做法
log.info("用户登录成功, userId: {}", userId);
log.error("用户登录失败, username: {}", username, e);

// 不好的做法
log.info("用户登录成功, userId: {}, password: {}", userId, password); // 密码不能记录
```

### 3.3 数据库操作规范

#### 3.3.1 表命名规范
- 表名：小写下划线分隔，使用复数形式或业务含义
- 示例：`user`、`user_info`、`question`、`answer_detail`

#### 3.3.2 字段命名规范
- 字段名：小写下划线分隔
- 主键：统一使用`id`
- 外键：`{table}_id`，如`user_id`、`question_id`
- 时间字段：`create_time`、`update_time`、`delete_time`
- 布尔字段：使用`is_`前缀，如`is_deleted`、`is_active`

#### 3.3.3 SQL规范
- 使用MyBatis-Plus时，简单CRUD使用内置方法
- 复杂查询使用XML Mapper，SQL要格式化
- 避免使用`SELECT *`，明确指定字段
- 使用参数化查询，防止SQL注入
- 合理使用索引，避免全表扫描

```java
// 好的做法
@Select("SELECT id, username, email FROM user WHERE id = #{id}")
User getUserById(@Param("id") Long id);

// 不好的做法
@Select("SELECT * FROM user WHERE id = " + id) // SQL注入风险
```

### 3.4 接口规范

#### 3.4.1 RESTful API设计
- **URL设计**：使用名词，不使用动词
  - 好的：`GET /api/users/{id}`
  - 不好的：`GET /api/getUserById`
- **HTTP方法**：
  - `GET`：查询
  - `POST`：创建
  - `PUT`：更新（全量）
  - `PATCH`：更新（部分）
  - `DELETE`：删除
- **状态码**：
  - `200`：成功
  - `201`：创建成功
  - `400`：请求参数错误
  - `401`：未授权
  - `403`：禁止访问
  - `404`：资源不存在
  - `500`：服务器错误

#### 3.4.2 统一响应格式

```java
public class Result<T> {
    private Integer code;        // 状态码
    private String message;      // 消息
    private T data;              // 数据
    private Long timestamp;      // 时间戳
}
```

**响应示例**：
```json
{
    "code": 200,
    "message": "成功",
    "data": {
        "id": 1,
        "username": "test"
    },
    "timestamp": 1706601600000
}
```

#### 3.4.3 接口版本管理
- 在URL中体现版本：`/api/v1/users`、`/api/v2/users`
- 或在Header中指定版本：`Accept: application/vnd.api.v1+json`

#### 3.4.4 接口文档规范
- 使用Apifox维护接口文档
- 每个接口必须包含：
  - 接口路径、方法、描述
  - 请求参数（类型、是否必填、说明）
  - 响应参数（类型、说明）
  - 错误码说明
  - Mock数据

---

## 四、提交规范

### 4.1 Git工作流

#### 4.1.1 分支策略

| 分支 | 说明 | 来源 | 合并到 |
|------|------|------|--------|
| **master** | 生产环境代码 | - | - |
| **develop** | 开发环境代码 | - | master |
| **feature** | 功能开发分支 | develop | develop |
| **hotfix** | 紧急修复分支 | master | master, develop |
| **release** | 发布分支 | develop | master, develop |

**分支命名规范**：
- feature：`feature/user-login`、`feature/question-crud`
- hotfix：`hotfix/fix-login-bug`
- release：`release/v1.0.0`

#### 4.1.2 提交规范

**提交信息格式**：`<type>(<scope>): <subject>`

**类型（type）**：
- `feat`：新功能
- `fix`：修复Bug
- `docs`：文档更新
- `style`：代码格式调整（不影响功能）
- `refactor`：代码重构
- `test`：测试相关
- `chore`：构建过程或辅助工具的变动

**范围（scope）**：模块名称，如`user`、`content`、`gateway`

**主题（subject）**：简洁描述变更内容

**提交示例**：
```
feat(user): 添加用户注册功能
fix(content): 修复问题列表分页Bug
docs(readme): 更新README文档
refactor(gateway): 重构JWT认证过滤器
```

#### 4.1.3 提交注意事项
- 每次提交只包含一个功能或修复
- 提交前确保代码可以编译通过
- 提交前运行单元测试（如果有）
- 提交信息要清晰明确，便于追溯

---

## 五、代码注意事项

### 5.1 性能优化

#### 5.1.1 数据库查询优化
- 避免N+1查询问题，使用批量查询或关联查询
- 合理使用索引，避免全表扫描
- 使用分页查询，避免一次性查询大量数据
- 使用缓存减少数据库查询

```java
// 不好的做法：N+1查询
List<User> users = userMapper.selectList();
for (User user : users) {
    List<Order> orders = orderMapper.selectByUserId(user.getId()); // 每次循环都查询
}

// 好的做法：批量查询
List<User> users = userMapper.selectList();
List<Long> userIds = users.stream().map(User::getId).collect(Collectors.toList());
List<Order> orders = orderMapper.selectByUserIds(userIds); // 一次查询
```

#### 5.1.2 缓存使用
- 热点数据使用Redis缓存
- 设置合理的过期时间
- 注意缓存穿透、缓存击穿、缓存雪崩问题
- 使用缓存更新策略（Cache Aside、Write Through、Write Back）

#### 5.1.3 异步处理
- 非关键路径使用异步处理（如发送通知、记录日志）
- 使用消息队列处理耗时任务
- 合理使用线程池，避免线程过多

### 5.2 安全性

#### 5.2.1 参数验证
- 所有用户输入必须验证
- 使用`@Valid`、`@NotNull`等注解验证
- 防止SQL注入、XSS攻击
- 敏感信息加密存储

```java
@PostMapping("/users")
public Result<UserVO> createUser(@Valid @RequestBody UserCreateDTO userDTO) {
    // @Valid会自动验证参数
    return Result.success(userService.createUser(userDTO));
}
```

#### 5.2.2 权限控制
- 使用Spring Security进行权限控制
- 接口级别的权限验证
- 数据级别的权限验证（用户只能操作自己的数据）

#### 5.2.3 敏感信息处理
- 密码不能明文存储，使用BCrypt加密
- Token不能泄露到日志
- 银行卡号、身份证号等敏感信息脱敏显示

### 5.3 异常处理

#### 5.3.1 异常分类
- **系统异常**：数据库连接失败、网络异常等
- **业务异常**：用户不存在、余额不足等
- **参数异常**：参数格式错误、必填参数缺失等

#### 5.3.2 异常处理原则
- 使用全局异常处理器统一处理异常
- 异常信息要清晰明确，便于排查问题
- 不要暴露系统内部信息给用户
- 记录异常日志，便于问题追踪

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(BusinessException.class)
    public Result<?> handleBusinessException(BusinessException e) {
        log.warn("业务异常: {}", e.getMessage());
        return Result.error(e.getCode(), e.getMessage());
    }
    
    @ExceptionHandler(Exception.class)
    public Result<?> handleException(Exception e) {
        log.error("系统异常", e);
        return Result.error(ResultCodeEnum.SYSTEM_ERROR);
    }
}
```

### 5.4 代码质量

#### 5.4.1 代码复用
- 提取公共方法，避免代码重复
- 使用工具类处理通用逻辑
- 合理使用设计模式

#### 5.4.2 代码可读性
- 方法名要清晰表达意图
- 方法不要过长，建议不超过50行
- 复杂逻辑要添加注释
- 使用有意义的变量名

#### 5.4.3 单元测试
- 核心业务逻辑要有单元测试
- 测试覆盖率要达到一定标准（建议70%以上）
- 使用Mock对象隔离依赖

### 5.5 配置管理

#### 5.5.1 配置文件
- 使用Spring Profile管理不同环境配置
- 敏感信息使用环境变量或配置中心
- 配置项要有默认值和说明

```yaml
spring:
  profiles:
    active: dev

---
spring:
  config:
    activate:
      on-profile: dev
  datasource:
    url: jdbc:mysql://localhost:3306/test_db
    username: root
    password: ${DB_PASSWORD:default_password}
```

#### 5.5.2 配置中心
- 使用Spring Cloud Config统一管理配置
- 配置变更要通知相关服务
- 配置要有版本管理

### 5.6 监控与日志

#### 5.6.1 日志记录
- 关键业务流程要记录日志
- 异常要记录详细日志
- 日志级别要合理使用
- 日志格式要统一

#### 5.6.2 监控指标
- 接口响应时间
- 接口调用次数
- 错误率
- 系统资源使用情况（CPU、内存、磁盘）

---

## 六、开发流程

### 6.1 开发前准备
1. 从develop分支创建feature分支
2. 确认需求和技术方案
3. 在Apifox中设计接口文档
4. 创建数据库表结构（如需要）

### 6.2 开发过程
1. 编写代码，遵循代码规范
2. 编写单元测试
3. 本地测试验证
4. 提交代码（遵循提交规范）

### 6.3 代码审查
1. 创建Pull Request
2. Code Review
3. 根据反馈修改代码
4. 合并到develop分支

### 6.4 测试与发布
1. 在测试环境部署
2. 功能测试
3. 性能测试
4. 发布到生产环境

---

## 七、常见问题

### 7.1 依赖冲突
- 使用Maven的`dependency:tree`查看依赖树
- 使用`<exclusions>`排除冲突依赖
- 统一管理依赖版本（在父POM中）

### 7.2 跨服务调用
- 使用OpenFeign进行服务间调用
- 设置合理的超时时间
- 使用熔断机制防止服务雪崩

### 7.3 分布式事务
- 使用Seata处理分布式事务
- 或使用最终一致性方案（消息队列）

---

*本文档会持续更新*
